name: Build macOS PKG (embedded JRE + tools)

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

jobs:
  build-pkg:
    runs-on: macos-latest

    env:
      APP_NAME: "Shutter Encoder Anatomia"
      APP_VERSION: "19.4.0"                       # ← PODMIEŃ
      PKG_IDENTIFIER: "pl.dabek86.shutterencoder" # ← PODMIEŃ

      # Włączą się same, jeśli dodasz sekrety
      SHOULD_SIGN: ${{ secrets.INSTALLER_CERT_P12 && secrets.INSTALLER_CERT_P12_PASSWORD && 'true' || 'false' }}
      CAN_NOTARIZE_API: ${{ secrets.NOTARY_API_KEY_ID && secrets.NOTARY_API_ISSUER && secrets.NOTARY_API_KEY && 'true' || 'false' }}
      CAN_NOTARIZE_APPLEID: ${{ secrets.APPLE_ID && secrets.TEAM_ID && secrets.APP_SPECIFIC_PW && 'true' || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Temurin JDK (jlink/jpackage)
        run: |
          brew update
          brew install --cask temurin

      - name: Install CLI tools via Homebrew (bez tsmuxer)
        run: |
          set -euo pipefail
          # + jq do parsowania API GitHuba (dla tsMuxer)
          brew install jq ffmpeg p7zip exiftool dcraw yt-dlp dvdauthor mediainfo bmx realesrgan-ncnn-vulkan

      - name: Fetch tsMuxer from GitHub Releases
        run: |
          set -euo pipefail
          mkdir -p downloads tools
          # Pobierz najnowsze release i wybierz asset dla macOS (prefer ARM64 / universal)
          API_URL="https://api.github.com/repos/justdan96/tsMuxer/releases/latest"
          ASSET_URL=$(
            curl -sL "$API_URL" \
            | jq -r '
                .assets
                | map(select(
                    (.name|test("mac|osx|darwin"; "i")) and
                    ((.name|test("arm64|aarch64|universal"; "i")) or (.name|test("mac|osx|darwin"; "i")))
                  ))
                | sort_by(.name)
                | reverse
                | .[0].browser_download_url // empty
              '
          )
          if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" = "null" ]; then
            echo "Nie znaleziono assetu tsMuxer dla macOS w najnowszym release." >&2
            exit 1
          fi
          echo "Pobieram: $ASSET_URL"
          FILENAME="downloads/tsmuxer-asset"
          curl -L "$ASSET_URL" -o "$FILENAME"

          # Rozpakuj różne możliwe formaty
          # Obsłuż .zip / .dmg / samodzielny bin
          if file "$FILENAME" | grep -qi 'Zip archive'; then
            ditto -x -k "$FILENAME" downloads/tsmuxer
          elif file "$FILENAME" | grep -qi 'application/x-apple-diskimage'; then
            MNT=$(mktemp -d)
            hdiutil attach "$FILENAME" -mountpoint "$MNT" -nobrowse -quiet
            # Spróbuj znaleźć binarkę CLI (zwykle "tsmuxer" lub "tsMuxeR")
            cp -Rv "$MNT"/* downloads/tsmuxer/ || true
            hdiutil detach "$MNT" -quiet
          else
            # Może to być bezpośrednio binarka
            mkdir -p downloads/tsmuxer
            cp "$FILENAME" downloads/tsmuxer/tsmuxer || true
            cp "$FILENAME" downloads/tsmuxer/tsMuxeR || true
          fi

          # Znormalizuj nazwę i skopiuj do tools/
          # Szukamy wykonywalnego pliku o nazwie tsmuxer lub tsMuxeR
          BIN_PATH=$( (find downloads/tsmuxer -type f -perm +111 -name "tsmuxer" -o -name "tsMuxeR" 2>/dev/null || true) | head -n1 )
          if [ -z "$BIN_PATH" ]; then
            # jeśli nic nie znaleziono, spróbuj szerzej
            BIN_PATH=$( (find downloads/tsmuxer -type f -perm +111 2>/dev/null || true) | grep -i "tsmux" | head -n1 )
          fi
          if [ -z "$BIN_PATH" ]; then
            echo "Nie udało się zlokalizować binarki tsMuxer po rozpakowaniu." >&2
            ls -la downloads/tsmuxer || true
            exit 1
          fi
          echo "Znaleziono tsMuxer: $BIN_PATH"
          cp "$BIN_PATH" tools/tsmuxer
          chmod +x tools/tsmuxer

      - name: Collect other tools into ./tools (binaries + optional models)
        run: |
          set -euo pipefail
          # Dokładamy binarki z Homebrew do ./tools
          copy_bin () {
            if command -v "$1" >/dev/null 2>&1; then
              cp "$(command -v "$1")" "tools/$1"
              chmod +x "tools/$1"
              echo "Copied $1 -> tools/$1"
            else
              echo "WARNING: $1 not found in PATH" >&2
            fi
          }

          copy_bin ffmpeg
          copy_bin 7za
          copy_bin exiftool
          copy_bin dcraw
          copy_bin yt-dlp
          copy_bin dvdauthor
          copy_bin mediainfo
          copy_bin bmxtranswrap
          copy_bin realesrgan-ncnn-vulkan

          # Modele Real-ESRGAN (jeśli zainstalowane przez brew)
          BREW_PREFIX=$(brew --prefix)
          if [ -d "$BREW_PREFIX/share/realesrgan-ncnn-vulkan" ]; then
            mkdir -p tools/realesrgan-models
            rsync -a "$BREW_PREFIX/share/realesrgan-ncnn-vulkan/" tools/realesrgan-models/
          fi

      - name: Build .app with jpackage + custom JRE + tools
        run: |
          set -euo pipefail
          rm -rf out stage res JRE
          mkdir -p out stage res

          # 1) Główny JAR do --input
          cp "Shutter Encoder.jar" stage/

          # 2) Zasoby do --resource-dir
          [ -d Library ] && rsync -a --delete --exclude '.DS_Store' Library/ res/Library/ || true
          [ -d fonts ]   && rsync -a --delete --exclude '.DS_Store' fonts/   res/fonts/   || true

          # 3) Dołącz narzędzia CLI jako bin/
          if [ -d tools ]; then
            mkdir -p res/bin
            rsync -a tools/ res/bin/
          fi

          # 4) Minimalny JRE przez jlink (Twoje moduły)
          jlink \
            --compress 0 \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --add-modules java.base,java.datatransfer,java.desktop,java.logging,java.security.sasl,java.xml,jdk.crypto.ec \
            --output JRE

          # 5) app-image (JRE w środku)
          jpackage \
            --type app-image \
            --name "${APP_NAME}" \
            --app-version "${APP_VERSION}" \
            --input stage \
            --main-jar "Shutter Encoder.jar" \
            --resource-dir res \
            --runtime-image JRE \
            --dest out

          # 6) Przenieś bin/ i modele do konwencjonalnego miejsca w bundle
          if [ -d "res/bin" ]; then
            mkdir -p "out/${APP_NAME}.app/Contents/Resources/bin"
            cp -R "res/bin/." "out/${APP_NAME}.app/Contents/Resources/bin/"
          fi
          if [ -d "tools/realesrgan-models" ]; then
            mkdir -p "out/${APP_NAME}.app/Contents/Resources/realesrgan-models"
            cp -R "tools/realesrgan-models/." "out/${APP_NAME}.app/Contents/Resources/realesrgan-models/"
          fi

      - name: Prepare payload for PKG
        run: |
          mkdir -p "payload/Applications"
          cp -R "out/${APP_NAME}.app" "payload/Applications/${APP_NAME}.app"

      - name: Compute payload stats
        id: stats
        run: |
          FILES=$(find payload -type f | wc -l | tr -d ' ')
          KBYTES=$(du -sk payload | awk '{print $1}')
          echo "files=$FILES" >> "$GITHUB_OUTPUT"
          echo "kbytes=$KBYTES" >> "$GITHUB_OUTPUT"

      - name: Create PackageInfo (minimal)
        run: |
          cat > PackageInfo <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <pkg-info format-version="2"
            identifier="${PKG_IDENTIFIER}"
            version="${APP_VERSION}"
            install-location="/"
            auth="root">
            <payload installKBytes="${{ steps.stats.outputs.kbytes }}" numberOfFiles="${{ steps.stats.outputs.files }}"/>
            <scripts/>
          </pkg-info>
          EOF
          sed -i '' "s|\${PKG_IDENTIFIER}|${PKG_IDENTIFIER}|g" PackageInfo
          sed -i '' "s|\${APP_VERSION}|${APP_VERSION}|g" PackageInfo

      - name: Build component package (pkgbuild)
        run: |
          pkgbuild \
            --root payload \
            --install-location / \
            --identifier "${PKG_IDENTIFIER}" \
            --version "${APP_VERSION}" \
            "${APP_NAME}-unsigned.pkg"

      # ====== (OPCJONALNIE) PODPIS ======
      - name: Import Developer ID Installer certificate
        if: env.SHOULD_SIGN == 'true'
        run: |
          echo "${{ secrets.INSTALLER_CERT_P12 }}" | base64 --decode > installer.p12
          security create-keychain -p temp build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p temp build.keychain
          security import installer.p12 -k build.keychain -P "${{ secrets.INSTALLER_CERT_P12_PASSWORD }}" -T /usr/bin/productsign -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k temp build.keychain
          rm -f installer.p12

      - name: Sign installer (productsign)
        if: env.SHOULD_SIGN == 'true'
        env:
          INSTALLER_CN: "Developer ID Installer: YOUR NAME (TEAMID)"   # ← PODMIEŃ
        run: |
          productsign \
            --sign "${INSTALLER_CN}" \
            "${APP_NAME}-unsigned.pkg" \
            "${APP_NAME}-signed.pkg"

      # ====== (OPCJONALNIE) NOTARYZACJA ======
      - name: Notarize with notarytool (API key)
        if: env.CAN_NOTARIZE_API == 'true'
        env:
          NOTARY_API_KEY_ID: ${{ secrets.NOTARY_API_KEY_ID }}
          NOTARY_API_ISSUER: ${{ secrets.NOTARY_API_ISSUER }}
          NOTARY_API_KEY: ${{ secrets.NOTARY_API_KEY }}
        run: |
          echo "$NOTARY_API_KEY" > api_key.p8
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --key api_key.p8 \
            --key-id "$NOTARY_API_KEY_ID" \
            --issuer "$NOTARY_API_ISSUER" \
            --wait
          rm -f api_key.p8

      - name: Notarize with notarytool (Apple ID)
        if: env.CAN_NOTARIZE_APPLEID == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
          APP_SPECIFIC_PW: ${{ secrets.APP_SPECIFIC_PW }}
        run: |
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APP_SPECIFIC_PW" \
            --wait

      - name: Staple ticket (optional)
        run: |
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          xcrun stapler staple "$PKG" || true

      - name: Prepare final artifact
        run: |
          mkdir -p dist
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          mv "$PKG" "dist/${APP_NAME}-${APP_VERSION}.pkg"

      - name: Upload final PKG (versioned)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.APP_VERSION }}
          path: dist/*.pkg
