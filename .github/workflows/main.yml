name: Build macOS PKG (embedded JRE + tools)

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

jobs:
  build-pkg:
    runs-on: macos-latest

    env:
      APP_NAME: "Shutter Encoder Anatomia"
      APP_VERSION: "19.4.0"                       # ← PODMIEŃ
      PKG_IDENTIFIER: "pl.dabek86.shutterencoder" # ← PODMIEŃ

      # Automatyczne flagi — aktywują podpis / notaryzację tylko jeśli dodasz sekrety
      SHOULD_SIGN: ${{ secrets.INSTALLER_CERT_P12 && secrets.INSTALLER_CERT_P12_PASSWORD && 'true' || 'false' }}
      CAN_NOTARIZE_API: ${{ secrets.NOTARY_API_KEY_ID && secrets.NOTARY_API_ISSUER && secrets.NOTARY_API_KEY && 'true' || 'false' }}
      CAN_NOTARIZE_APPLEID: ${{ secrets.APPLE_ID && secrets.TEAM_ID && secrets.APP_SPECIFIC_PW && 'true' || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Temurin JDK (jlink/jpackage)
        run: |
          brew update
          brew install --cask temurin

      - name: Install CLI tools via Homebrew (bez bmx/tsmuxer)
        run: |
          set -euo pipefail
          brew install jq ffmpeg p7zip exiftool dcraw yt-dlp dvdauthor realesrgan-ncnn-vulkan
          brew install --cask mediainfo

      - name: Fetch tsMuxer + bmxtranswrap manually
        run: |
          set -euo pipefail
          mkdir -p downloads tools

          # === tsMuxer z GitHub Releases ===
          API_URL="https://api.github.com/repos/justdan96/tsMuxer/releases/latest"
          ASSET_URL=$(curl -sL "$API_URL" | jq -r '.assets[]?.browser_download_url | select(test("mac|osx|darwin"; "i"))' | head -n1)
          if [ -z "$ASSET_URL" ]; then
            echo "Nie znaleziono assetu tsMuxer dla macOS." >&2
            exit 1
          fi
          echo "Pobieram tsMuxer: $ASSET_URL"
          curl -L "$ASSET_URL" -o downloads/tsmuxer-asset.zip
          ditto -x -k downloads/tsmuxer-asset.zip downloads/tsmuxer || true
          BIN_TSMUXER=$(find downloads/tsmuxer -type f -perm +111 -name "tsmuxer" -o -name "tsMuxeR" 2>/dev/null | head -n1)
          if [ -n "$BIN_TSMUXER" ]; then
            cp "$BIN_TSMUXER" tools/tsmuxer && chmod +x tools/tsmuxer
          else
            echo "Nie znaleziono binarki tsMuxer" >&2; exit 1
          fi

          # === bmxtranswrap z SourceForge (binarka macOS Intel) ===
          echo "Pobieram bmxtranswrap..."
          curl -L "https://downloads.sourceforge.net/project/bmxlib/bmx/bmx-0.2.4/bmx-0.2.4-macosx.zip" -o downloads/bmx.zip
          ditto -x -k downloads/bmx.zip downloads/bmx || true
          BIN_BMX=$(find downloads/bmx -type f -perm +111 -name "bmxtranswrap" 2>/dev/null | head -n1)
          if [ -n "$BIN_BMX" ]; then
            cp "$BIN_BMX" tools/bmxtranswrap && chmod +x tools/bmxtranswrap
          else
            echo "Nie znaleziono binarki bmxtranswrap" >&2; exit 1
          fi

      - name: Collect Homebrew tools into ./tools (binaries + optional models)
        run: |
          set -euo pipefail

          copy_bin () {
            if command -v "$1" >/dev/null 2>&1; then
              cp "$(command -v "$1")" "tools/$1"
              chmod +x "tools/$1"
              echo "Copied $1 -> tools/$1"
            else
              echo "WARNING: $1 not found in PATH" >&2
            fi
          }

          copy_bin ffmpeg
          copy_bin 7za
          copy_bin exiftool
          copy_bin dcraw
          copy_bin yt-dlp
          copy_bin dvdauthor
          copy_bin mediainfo
          copy_bin realesrgan-ncnn-vulkan

          # Modele Real-ESRGAN (jeśli zainstalowane przez brew)
          BREW_PREFIX=$(brew --prefix)
          if [ -d "$BREW_PREFIX/share/realesrgan-ncnn-vulkan" ]; then
            mkdir -p tools/realesrgan-models
            rsync -a "$BREW_PREFIX/share/realesrgan-ncnn-vulkan/" tools/realesrgan-models/
          fi

      - name: Build .app with jpackage + custom JRE + tools
        run: |
          set -euo pipefail
          rm -rf out stage res JRE
          mkdir -p out stage res

          # 1) Główny JAR do --input
          cp "Shutter Encoder.jar" stage/

          # 2) Zasoby do --resource-dir
          [ -d Library ] && rsync -a --delete --exclude '.DS_Store' Library/ res/Library/ || true
          [ -d fonts ]   && rsync -a --delete --exclude '.DS_Store' fonts/   res/fonts/   || true

          # 3) Dołącz narzędzia CLI jako bin/
          if [ -d tools ]; then
            mkdir -p res/bin
            rsync -a tools/ res/bin/
          fi

          # 4) Minimalny JRE przez jlink (Twoje moduły)
          jlink \
            --compress 0 \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --add-modules java.base,java.datatransfer,java.desktop,java.logging,java.security.sasl,java.xml,jdk.crypto.ec \
            --output JRE

          # 5) app-image (JRE w środku)
          jpackage \
            --type app-image \
            --name "${APP_NAME}" \
            --app-version "${APP_VERSION}" \
            --input stage \
            --main-jar "Shutter Encoder.jar" \
            --resource-dir res \
            --runtime-image JRE \
            --dest out

          # 6) Przenieś bin/ i modele do konwencjonalnego miejsca w bundle
          if [ -d "res/bin" ]; then
            mkdir -p "out/${APP_NAME}.app/Contents/Resources/bin"
            cp -R "res/bin/." "out/${APP_NAME}.app/Contents/Resources/bin/"
          fi
          if [ -d "tools/realesrgan-models" ]; then
            mkdir -p "out/${APP_NAME}.app/Contents/Resources/realesrgan-models"
            cp -R "tools/realesrgan-models/." "out/${APP_NAME}.app/Contents/Resources/realesrgan-models/"
          fi

      - name: Prepare payload for PKG
        run: |
          mkdir -p "payload/Applications"
          cp -R "out/${APP_NAME}.app" "payload/Applications/${APP_NAME}.app"

      - name: Compute payload stats
        id: stats
        run: |
          FILES=$(find payload -type f | wc -l | tr -d ' ')
          KBYTES=$(du -sk payload | awk '{print $1}')
          echo "files=$FILES" >> "$GITHUB_OUTPUT"
          echo "kbytes=$KBYTES" >> "$GITHUB_OUTPUT"

      - name: Create PackageInfo (minimal)
        run: |
          cat > PackageInfo <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <pkg-info format-version="2"
            identifier="${PKG_IDENTIFIER}"
            version="${APP_VERSION}"
            install-location="/"
            auth="root">
            <payload installKBytes="${{ steps.stats.outputs.kbytes }}" numberOfFiles="${{ steps.stats.outputs.files }}"/>
            <scripts/>
          </pkg-info>
          EOF
          sed -i '' "s|\${PKG_IDENTIFIER}|${PKG_IDENTIFIER}|g" PackageInfo
          sed -i '' "s|\${APP_VERSION}|${APP_VERSION}|g" PackageInfo

      - name: Build component package (pkgbuild)
        run: |
          pkgbuild \
            --root payload \
            --install-location / \
            --identifier "${PKG_IDENTIFIER}" \
            --version "${APP_VERSION}" \
            "${APP_NAME}-unsigned.pkg"

      # ====== (OPCJONALNIE) PODPIS ======
      - name: Import Developer ID Installer certificate
        if: env.SHOULD_SIGN == 'true'
        run: |
          echo "${{ secrets.INSTALLER_CERT_P12 }}" | base64 --decode > installer.p12
          security create-keychain -p temp build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p temp build.keychain
          security import installer.p12 -k build.keychain -P "${{ secrets.INSTALLER_CERT_P12_PASSWORD }}" -T /usr/bin/productsign -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k temp build.keychain
          rm -f installer.p12

      - name: Sign installer (productsign)
        if: env.SHOULD_SIGN == 'true'
        env:
          INSTALLER_CN: "Developer ID Installer: YOUR NAME (TEAMID)"   # ← PODMIEŃ
        run: |
          productsign \
            --sign "${INSTALLER_CN}" \
            "${APP_NAME}-unsigned.pkg" \
            "${APP_NAME}-signed.pkg"

      # ====== (OPCJONALNIE) NOTARYZACJA ======
      - name: Notarize with notarytool (API key)
        if: env.CAN_NOTARIZE_API == 'true'
        env:
          NOTARY_API_KEY_ID: ${{ secrets.NOTARY_API_KEY_ID }}
          NOTARY_API_ISSUER: ${{ secrets.NOTARY_API_ISSUER }}
          NOTARY_API_KEY: ${{ secrets.NOTARY_API_KEY }}
        run: |
          echo "$NOTARY_API_KEY" > api_key.p8
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --key api_key.p8 \
            --key-id "$NOTARY_API_KEY_ID" \
            --issuer "$NOTARY_API_ISSUER" \
            --wait
          rm -f api_key.p8

      - name: Notarize with notarytool (Apple ID)
        if: env.CAN_NOTARIZE_APPLEID == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
          APP_SPECIFIC_PW: ${{ secrets.APP_SPECIFIC_PW }}
        run: |
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APP_SPECIFIC_PW" \
            --wait

      - name: Staple ticket (optional)
        run: |
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          xcrun stapler staple "$PKG" || true

      - name: Prepare final artifact
        run: |
          mkdir -p dist
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          mv "$PKG" "dist/${APP_NAME}-${APP_VERSION}.pkg"

      - name: Upload final PKG (versioned)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.APP_VERSION }}
          path: dist/*.pkg
