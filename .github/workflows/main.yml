name: Build macOS PKG (embedded JRE + bundled CLI tools)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-pkg:
    runs-on: macos-latest

    env:
      APP_NAME: "Shutter Encoder Anatomia"          # nazwa pakietu .app
      APP_VERSION: "19.4.0"                         # ← PODMIEŃ
      PKG_IDENTIFIER: "pl.dabek86.shutterencoder"   # ← PODMIEŃ (reverse-DNS)

      # Te flagi same włączą się, jeśli dodasz odpowiednie sekrety
      SHOULD_SIGN: ${{ secrets.INSTALLER_CERT_P12 && secrets.INSTALLER_CERT_P12_PASSWORD && 'true' || 'false' }}
      CAN_NOTARIZE_API: ${{ secrets.NOTARY_API_KEY_ID && secrets.NOTARY_API_ISSUER && secrets.NOTARY_API_KEY && 'true' || 'false' }}
      CAN_NOTARIZE_APPLEID: ${{ secrets.APPLE_ID && secrets.TEAM_ID && secrets.APP_SPECIFIC_PW && 'true' || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Temurin JDK (for jlink/jpackage)
        run: |
          brew update
          brew install --cask temurin

      - name: Install CLI tools via Homebrew
        run: |
          set -euo pipefail
          # Zestaw narzędzi:
          # ffmpeg, 7za (z p7zip), exiftool, dcraw, yt-dlp, dvdauthor, tsmuxer, mediainfo, bmx (z bmxtranswrap), realesrgan-ncnn-vulkan
          brew install ffmpeg p7zip exiftool dcraw yt-dlp dvdauthor tsmuxer mediainfo bmx realesrgan-ncnn-vulkan

      - name: Collect tools into ./tools (binaries + optional model files)
        run: |
          set -euo pipefail
          rm -rf tools && mkdir -p tools

          copy_bin () { 
            if command -v "$1" >/dev/null 2>&1; then 
              cp "$(command -v "$1")" "tools/$1"
              chmod +x "tools/$1"
              echo "Copied $1 -> tools/$1"
            else
              echo "WARNING: $1 not found in PATH" >&2
            fi
          }

          # Binarne nazwy
          copy_bin ffmpeg
          copy_bin 7za
          copy_bin exiftool
          copy_bin dcraw
          copy_bin yt-dlp
          copy_bin dvdauthor
          copy_bin tsmuxer
          copy_bin mediainfo
          copy_bin bmxtranswrap
          copy_bin realesrgan-ncnn-vulkan

          # Dodatkowe zasoby modeli (jeśli formuła je zainstalowała)
          # Real-ESRGAN NCNN: modele bywają w .../share/realesrgan-ncnn-vulkan/models
          BREW_PREFIX=$(brew --prefix)
          if [ -d "$BREW_PREFIX/share/realesrgan-ncnn-vulkan" ]; then
            mkdir -p tools/realesrgan-models
            rsync -a "$BREW_PREFIX/share/realesrgan-ncnn-vulkan/" tools/realesrgan-models/
            echo "Copied Real-ESRGAN NCNN models."
          fi

      - name: Build .app with jpackage + custom JRE + tools
        run: |
          set -euo pipefail

          # 0) Porządek
          rm -rf out stage res JRE
          mkdir -p out stage res

          # 1) Staging: tylko główny JAR (do --input)
          cp "Shutter Encoder.jar" stage/

          # 2) Zasoby (Library, fonts)
          [ -d Library ] && rsync -a --delete --exclude '.DS_Store' Library/ res/Library/ || true
          [ -d fonts ]   && rsync -a --delete --exclude '.DS_Store' fonts/   res/fonts/   || true

          # 3) Dołączamy narzędzia CLI jako bin/ (trafią do Contents/Resources/bin po przeniesieniu)
          if [ -d tools ]; then
            mkdir -p res/bin
            rsync -a tools/ res/bin/
          fi

          # 4) Minimalny JRE przez jlink (Twój zestaw modułów)
          jlink \
            --compress 0 \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --add-modules java.base,java.datatransfer,java.desktop,java.logging,java.security.sasl,java.xml,jdk.crypto.ec \
            --output JRE

          # 5) Generujemy app-image (JRE w środku)
          jpackage \
            --type app-image \
            --name "${APP_NAME}" \
            --app-version "${APP_VERSION}" \
            --input stage \
            --main-jar "Shutter Encoder.jar" \
            --resource-dir res \
            --runtime-image JRE \
            --dest out

          # 6) Konwencjonalne miejsce na narzędzia: Contents/Resources/bin
          # (jpackage umieszcza res/ jako Contents/app/*, dlatego przenosimy bin/ do Resources)
          if [ -d "res/bin" ]; then
            mkdir -p "out/${APP_NAME}.app/Contents/Resources/bin"
            cp -R "res/bin/." "out/${APP_NAME}.app/Contents/Resources/bin/"
          fi
          # Jeśli są modele Real-ESRGAN — też wrzućmy je do Resources
          if [ -d "tools/realesrgan-models" ]; then
            mkdir -p "out/${APP_NAME}.app/Contents/Resources/realesrgan-models"
            cp -R "tools/realesrgan-models/." "out/${APP_NAME}.app/Contents/Resources/realesrgan-models/"
          fi

      - name: Prepare payload for PKG
        run: |
          mkdir -p "payload/Applications"
          cp -R "out/${APP_NAME}.app" "payload/Applications/${APP_NAME}.app"

      - name: Compute payload stats
        id: stats
        run: |
          FILES=$(find payload -type f | wc -l | tr -d ' ')
          KBYTES=$(du -sk payload | awk '{print $1}')
          echo "files=$FILES" >> $GITHUB_OUTPUT
          echo "kbytes=$KBYTES" >> $GITHUB_OUTPUT

      - name: Create PackageInfo (minimal)
        run: |
          cat > PackageInfo <<EOF
          <?xml version="1.0" encoding="utf-8"?>
          <pkg-info format-version="2"
            identifier="${PKG_IDENTIFIER}"
            version="${APP_VERSION}"
            install-location="/"
            auth="root">
            <payload installKBytes="${{ steps.stats.outputs.kbytes }}" numberOfFiles="${{ steps.stats.outputs.files }}"/>
            <scripts/>
          </pkg-info>
          EOF

      - name: Build component package (pkgbuild)
        run: |
          pkgbuild \
            --root payload \
            --install-location / \
            --identifier "${PKG_IDENTIFIER}" \
            --version "${APP_VERSION}" \
            "${APP_NAME}-unsigned.pkg"

      # ========= (OPCJONALNIE) PODPIS =========
      - name: Import Developer ID Installer certificate
        if: env.SHOULD_SIGN == 'true'
        run: |
          echo "${{ secrets.INSTALLER_CERT_P12 }}" | base64 --decode > installer.p12
          security create-keychain -p temp build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p temp build.keychain
          security import installer.p12 -k build.keychain -P "${{ secrets.INSTALLER_CERT_P12_PASSWORD }}" -T /usr/bin/productsign -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k temp build.keychain
          rm -f installer.p12

      - name: Sign installer (productsign)
        if: env.SHOULD_SIGN == 'true'
        env:
          # Podmień na dokładną nazwę certyfikatu w Keychain:
          INSTALLER_CN: "Developer ID Installer: YOUR NAME (TEAMID)"
        run: |
          productsign \
            --sign "${INSTALLER_CN}" \
            "${APP_NAME}-unsigned.pkg" \
            "${APP_NAME}-signed.pkg"

      # ========= (OPCJONALNIE) NOTARYZACJA =========
      - name: Notarize with notarytool (API key)
        if: env.CAN_NOTARIZE_API == 'true'
        env:
          NOTARY_API_KEY_ID: ${{ secrets.NOTARY_API_KEY_ID }}
          NOTARY_API_ISSUER: ${{ secrets.NOTARY_API_ISSUER }}
          NOTARY_API_KEY: ${{ secrets.NOTARY_API_KEY }}
        run: |
          echo "$NOTARY_API_KEY" > api_key.p8
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --key api_key.p8 \
            --key-id "$NOTARY_API_KEY_ID" \
            --issuer "$NOTARY_API_ISSUER" \
            --wait
          rm -f api_key.p8

      - name: Notarize with notarytool (Apple ID)
        if: env.CAN_NOTARIZE_APPLEID == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
          APP_SPECIFIC_PW: ${{ secrets.APP_SPECIFIC_PW }}
        run: |
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APP_SPECIFIC_PW" \
            --wait

      - name: Staple ticket (optional)
        run: |
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          xcrun stapler staple "$PKG" || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg
          path: |
            ${APP_NAME}-signed.pkg
            ${APP_NAME}-unsigned.pkg
            dist/*.pkg
        if-no-files-found: ignore

      - name: Prepare final artifact in /dist
        run: |
          mkdir -p dist
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          mv "$PKG" "dist/${APP_NAME}-${APP_VERSION}.pkg"

      - name: Upload final PKG (versioned)
        uses: actions/upload-artifact@v4
        with:
          name: ${APP_NAME}-${APP_VERSION}
          path: dist/*.pkg
