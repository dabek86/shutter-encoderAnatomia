name: Build macOS PKG (embedded JRE + GitHub tools)

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

jobs:
  build-pkg:
    runs-on: macos-latest

    env:
      APP_NAME: "Shutter Encoder Anatomia"
      APP_VERSION: "19.4.0"                       # ← PODMIEŃ
      PKG_IDENTIFIER: "pl.dabek86.shutterencoder" # ← PODMIEŃ

      SHOULD_SIGN: ${{ secrets.INSTALLER_CERT_P12 && secrets.INSTALLER_CERT_P12_PASSWORD && 'true' || 'false' }}
      CAN_NOTARIZE_API: ${{ secrets.NOTARY_API_KEY_ID && secrets.NOTARY_API_ISSUER && secrets.NOTARY_API_KEY && 'true' || 'false' }}
      CAN_NOTARIZE_APPLEID: ${{ secrets.APPLE_ID && secrets.TEAM_ID && secrets.APP_SPECIFIC_PW && 'true' || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Temurin JDK + tools
        run: |
          brew update
          brew install --cask temurin
          brew install jq coreutils

      - name: Download all CLI tools (robust)
        run: |
          set -euo pipefail
          mkdir -p downloads tools

          require_zip () {
            local f="$1"
            if ! file "$f" | grep -qi 'Zip archive'; then
              echo "ERROR: $f nie jest ZIP-em"; exit 1
            fi
          }

          unzip_first_exec () {
            local zip="$1" outdir="$2" pattern="$3" outname="$4"
            require_zip "$zip"
            rm -rf "$outdir"; mkdir -p "$outdir"
            ditto -x -k "$zip" "$outdir"
            local bin
            bin=$(find "$outdir" -type f -perm +111 -name "$pattern" 2>/dev/null | head -n1 || true)
            if [ -z "${bin:-}" ]; then
              bin=$(find "$outdir" -type f -name "$pattern" 2>/dev/null | head -n1 || true)
              [ -n "${bin:-}" ] && chmod +x "$bin"
            fi
            [ -n "${bin:-}" ] || { echo "Nie znaleziono $pattern w $zip"; exit 1; }
            cp "$bin" "tools/$outname"
            chmod +x "tools/$outname"
          }

          # ---------- FFmpeg (Evermeet: stabilne ZIP/API) ----------
          echo ">> FFmpeg (Evermeet)"
          curl -sSL "https://evermeet.cx/ffmpeg/get/zip" -o downloads/ffmpeg.zip
          require_zip downloads/ffmpeg.zip
          unzip_first_exec downloads/ffmpeg.zip downloads/ffmpeg ffmpeg ffmpeg

          # ---------- yt-dlp ----------
          echo ">> yt-dlp"
          curl -sSL "https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp_macos" -o tools/yt-dlp
          chmod +x tools/yt-dlp

          # ---------- 7za (7-zip.org: 7zz → 7za) ----------
          echo ">> 7za (7-zip.org)"
          mkdir -p downloads/7zip
          Z7_URL_PRIMARY="https://www.7-zip.org/a/7z2408-mac.tar.xz"
          Z7_URL_FALLBACK="https://www.7-zip.org/a/7z2301-mac.tar.xz"
          curl -sSL "$Z7_URL_PRIMARY" -o downloads/7zip.tar.xz || true
          if ! file downloads/7zip.tar.xz | grep -qi 'XZ compressed data'; then
            echo "Primary 7zip URL failed, trying fallback…"
            curl -sSL "$Z7_URL_FALLBACK" -o downloads/7zip.tar.xz
          fi
          if ! file downloads/7zip.tar.xz | grep -qi 'XZ compressed data'; then
            echo "ERROR: 7zip tar.xz is not valid"; exit 1
          fi
          tar -xJf downloads/7zip.tar.xz -C downloads/7zip
          [ -f downloads/7zip/7zz ] || { echo "ERROR: 7zz not found"; exit 1; }
          cp downloads/7zip/7zz tools/7za
          chmod +x tools/7za

          # ---------- dcraw ----------
          echo ">> dcraw"
          curl -sSL "https://raw.githubusercontent.com/entz/dcraw-mac/master/dcraw" -o tools/dcraw
          chmod +x tools/dcraw

          # ---------- exiftool (auto-version via ver.txt → SF → GitHub fallback) ----------
          echo ">> exiftool"
          EXIF_VER=$(curl -fsSL "https://exiftool.org/ver.txt" | tr -d '\r' || true)
          if [ -z "${EXIF_VER:-}" ]; then
            # awaryjnie spróbuj wyciągnąć nazwę z HTML
            EXIF_VER=$(curl -fsSL "https://exiftool.org/" | grep -Eo 'Image-ExifTool-[0-9]+\.[0-9]+\.tar\.gz' | head -n1 | sed -E 's/.*Image-ExifTool-([0-9]+\.[0-9]+)\.tar\.gz/\1/' || true)
          fi
          if [ -z "${EXIF_VER:-}" ]; then
            echo "Nie udało się ustalić wersji exiftool – spróbuję GitHub Releases…"
          fi

          EXIF_TGZ=""
          if [ -n "${EXIF_VER:-}" ]; then
            # 1) exiftool.org
            CAND1="https://exiftool.org/Image-ExifTool-${EXIF_VER}.tar.gz"
            echo "Próba: $CAND1"
            curl -fsSL "$CAND1" -o downloads/exiftool.tar.gz || true
            if file downloads/exiftool.tar.gz | grep -qi 'gzip compressed data'; then
              EXIF_TGZ="downloads/exiftool.tar.gz"
            else
              # 2) SourceForge mirror tej samej wersji
              CAND2="https://downloads.sourceforge.net/project/exiftool/Image-ExifTool-${EXIF_VER}.tar.gz"
              echo "Próba: $CAND2"
              curl -fsSL "$CAND2" -o downloads/exiftool.tar.gz || true
              if file downloads/exiftool.tar.gz | grep -qi 'gzip compressed data'; then
                EXIF_TGZ="downloads/exiftool.tar.gz"
              fi
            end
          fi

          if [ -z "$EXIF_TGZ" ]; then
            # 3) GitHub Releases: weź pierwszy .tar.gz asset
            EXIF_API="https://api.github.com/repos/exiftool/exiftool/releases/latest"
            GH_TGZ=$(curl -sSL "$EXIF_API" | jq -r '.assets[]?.browser_download_url | select(endswith(".tar.gz"))' | head -n1)
            [ -n "$GH_TGZ" ] || { echo "ERROR: brak assetów exiftool (.tar.gz) w GitHub Releases"; exit 1; }
            curl -fsSL "$GH_TGZ" -o downloads/exiftool.tar.gz
            file downloads/exiftool.tar.gz | grep -qi 'gzip compressed data' || { echo "ERROR: exiftool tar.gz invalid"; exit 1; }
            EXIF_TGZ="downloads/exiftool.tar.gz"
          fi

          mkdir -p downloads/exiftool
          tar -xzf "$EXIF_TGZ" -C downloads/exiftool --strip-components=1
          # skrypt + cały katalog lib (Perl) → obok binarek CLI
          cp downloads/exiftool/exiftool tools/exiftool
          chmod +x tools/exiftool
          if [ -d downloads/exiftool/lib ]; then
            mkdir -p tools/lib
            rsync -a downloads/exiftool/lib/ tools/lib/
          fi

          # ---------- dvdauthor ----------
          echo ">> dvdauthor"
          curl -sSL "https://downloads.sourceforge.net/project/dvdauthor/dvdauthor/0.7.2/dvdauthor-0.7.2-macos.zip" -o downloads/dvdauthor.zip
          unzip_first_exec downloads/dvdauthor.zip downloads/dvdauthor dvdauthor dvdauthor

          # ---------- tsMuxer ----------
          echo ">> tsMuxer"
          TS_API="https://api.github.com/repos/justdan96/tsMuxer/releases/latest"
          TS_URL=$(curl -sSL "$TS_API" | jq -r '.assets[]?.browser_download_url
                    | select(test("mac|osx|darwin";"i"))
                    | select(endswith(".zip") or endswith(".dmg"))' | head -n1)
          [ -n "$TS_URL" ] || { echo "Brak assetu tsMuxer dla macOS"; exit 1; }
          if echo "$TS_URL" | grep -qi '\.zip$'; then
            curl -sSL "$TS_URL" -o downloads/tsmuxer.zip
            unzip_first_exec downloads/tsmuxer.zip downloads/tsmuxer 'tsmuxer|tsMuxeR' tsmuxer
          else
            curl -sSL "$TS_URL" -o downloads/tsmuxer.dmg
            MNT=$(mktemp -d)
            hdiutil attach downloads/tsmuxer.dmg -mountpoint "$MNT" -nobrowse -quiet
            CAND=$(find "$MNT" -type f -perm +111 -name "tsmuxer" -o -name "tsMuxeR" 2>/dev/null | head -n1 || true)
            [ -n "${CAND:-}" ] || { echo "Nie znaleziono binarki w DMG tsMuxer"; hdiutil detach "$MNT" -quiet; exit 1; }
            cp "$CAND" tools/tsmuxer && chmod +x tools/tsmuxer
            hdiutil detach "$MNT" -quiet
          fi

          # ---------- bmxtranswrap ----------
          echo ">> bmxtranswrap"
          curl -sSL "https://downloads.sourceforge.net/project/bmxlib/bmx/bmx-0.2.4/bmx-0.2.4-macosx.zip" -o downloads/bmx.zip
          unzip_first_exec downloads/bmx.zip downloads/bmx bmxtranswrap bmxtranswrap

          # ---------- Real-ESRGAN ----------
          echo ">> Real-ESRGAN ncnn Vulkan"
          RG_API="https://api.github.com/repos/xinntao/Real-ESRGAN-ncnn-vulkan/releases/latest"
          RG_URL=$(curl -sSL "$RG_API" | jq -r '.assets[]?.browser_download_url
                    | select(test("mac|osx";"i"))
                    | select(endswith(".zip"))' | head -n1)
          [ -n "$RG_URL" ] || RG_URL="https://github.com/xinntao/Real-ESRGAN-ncnn-vulkan/releases/download/v0.2.0/realesrgan-ncnn-vulkan-v0.2.0-macos.zip"
          curl -sSL "$RG_URL" -o downloads/realesrgan.zip
          require_zip downloads/realesrgan.zip
          rm -rf downloads/realesrgan; mkdir -p downloads/realesrgan
          ditto -x -k downloads/realesrgan.zip downloads/realesrgan
          BIN_RG=$(find downloads/realesrgan -type f -perm +111 -name "realesrgan-ncnn-vulkan" 2>/dev/null | head -n1 || true)
          [ -n "${BIN_RG:-}" ] || { echo "Nie znaleziono binarki realesrgan-ncnn-vulkan"; exit 1; }
          cp "$BIN_RG" tools/realesrgan-ncnn-vulkan && chmod +x tools/realesrgan-ncnn-vulkan
          if [ -d "downloads/realesrgan/models" ]; then
            mkdir -p tools/realesrgan-models
            cp -R downloads/realesrgan/models/* tools/realesrgan-models/ || true
          fi

          # ---------- MediaInfo ----------
          echo ">> MediaInfo CLI"
          MI_URL="https://mediaarea.net/download/binary/mediainfo/25.07/MediaInfo_CLI_25.07_Mac.dmg"
          curl -sSL "$MI_URL" -o downloads/mediainfo.dmg
          MNT=$(mktemp -d)
          hdiutil attach downloads/mediainfo.dmg -mountpoint "$MNT" -nobrowse -quiet
          CAND=$(find "$MNT" -type f -name "mediainfo" -perm +111 2>/dev/null | head -n1 || true)
          [ -n "${CAND:-}" ] || { echo "Nie znaleziono mediainfo w DMG"; hdiutil detach "$MNT" -quiet; exit 1; }
          cp "$CAND" tools/mediainfo && chmod +x tools/mediainfo
          hdiutil detach "$MNT" -quiet

      - name: Build .app with jpackage + custom JRE + tools
        run: |
          set -euo pipefail
          rm -rf out stage res JRE
          mkdir -p out stage res

          cp "Shutter Encoder.jar" stage/
          [ -d Library ] && rsync -a Library/ res/Library/ || true
          [ -d fonts ] && rsync -a fonts/ res/fonts/ || true

          mkdir -p res/bin
          rsync -a tools/ res/bin/

          jlink \
            --compress 0 \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --add-modules java.base,java.datatransfer,java.desktop,java.logging,java.security.sasl,java.xml,jdk.crypto.ec \
            --output JRE

          jpackage \
            --type app-image \
            --name "${APP_NAME}" \
            --app-version "${APP_VERSION}" \
            --input stage \
            --main-jar "Shutter Encoder.jar" \
            --resource-dir res \
            --runtime-image JRE \
            --dest out

          mkdir -p "out/${APP_NAME}.app/Contents/Resources/bin"
          cp -R "res/bin/." "out/${APP_NAME}.app/Contents/Resources/bin/"
          if [ -d "tools/realesrgan-models" ]; then
            mkdir -p "out/${APP_NAME}.app/Contents/Resources/realesrgan-models"
            cp -R "tools/realesrgan-models/." "out/${APP_NAME}.app/Contents/Resources/realesrgan-models/"
          fi

      - name: Prepare payload for PKG
        run: |
          mkdir -p "payload/Applications"
          cp -R "out/${APP_NAME}.app" "payload/Applications/${APP_NAME}.app"

      - name: Build .pkg
        run: |
          pkgbuild \
            --root payload \
            --install-location / \
            --identifier "${PKG_IDENTIFIER}" \
            --version "${APP_VERSION}" \
            "${APP_NAME}-unsigned.pkg"

      - name: Upload final PKG
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.APP_VERSION }}
          path: "${{ env.APP_NAME }}-unsigned.pkg"
