name: Build macOS PKG (with embedded JRE)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-pkg:
    runs-on: macos-latest

    env:
      APP_NAME: "Shutter Encoder Anatomia"              # ← nazwa aplikacji (.app)
      APP_VERSION: "19.4.0"                             # ← PODMIEŃ na swoją wersję
      PKG_IDENTIFIER: "pl.dabek86.shutterencoder"       # ← PODMIEŃ na swój reverse-DNS

      # Przełączniki zależne od sekretów — jeśli brak, kroki się pominą
      SHOULD_SIGN: ${{ secrets.INSTALLER_CERT_P12 && secrets.INSTALLER_CERT_P12_PASSWORD && 'true' || 'false' }}
      CAN_NOTARIZE_API: ${{ secrets.NOTARY_API_KEY_ID && secrets.NOTARY_API_ISSUER && secrets.NOTARY_API_KEY && 'true' || 'false' }}
      CAN_NOTARIZE_APPLEID: ${{ secrets.APPLE_ID && secrets.TEAM_ID && secrets.APP_SPECIFIC_PW && 'true' || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Temurin JDK (jlink/jpackage)
        run: |
          brew update
          brew install --cask temurin

      - name: Build .app with jpackage + custom JRE (jlink)
        run: |
          set -euo pipefail

          # 0) Porządkowanie katalogów
          rm -rf out stage res JRE
          mkdir -p out stage res

          # 1) Staging: tylko główny JAR do --input
          cp "Shutter Encoder.jar" stage/

          # 2) Zasoby do --resource-dir (BEZ out/, .git itd.)
          [ -d Library ] && rsync -a --delete --exclude '.DS_Store' Library/ res/Library/ || true
          [ -d fonts ]   && rsync -a --delete --exclude '.DS_Store' fonts/   res/fonts/   || true

          # 3) Budowa minimalnego JRE (dokładnie jak podałeś)
          jlink \
            --compress 0 \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --add-modules java.base,java.datatransfer,java.desktop,java.logging,java.security.sasl,java.xml,jdk.crypto.ec \
            --output JRE

          # 4) Generacja app-image z wbudowanym JRE
          jpackage \
            --type app-image \
            --name "${APP_NAME}" \
            --app-version "${APP_VERSION}" \
            --input stage \
            --main-jar "Shutter Encoder.jar" \
            --resource-dir res \
            --runtime-image JRE \
            --dest out

          # out/${APP_NAME}.app gotowe (z runtime w środku)

      - name: Prepare payload for PKG
        run: |
          mkdir -p "payload/Applications"
          cp -R "out/${APP_NAME}.app" "payload/Applications/${APP_NAME}.app"

      - name: Compute payload stats
        id: stats
        run: |
          FILES=$(find payload -type f | wc -l | tr -d ' ')
          KBYTES=$(du -sk payload | awk '{print $1}')
          echo "files=$FILES" >> $GITHUB_OUTPUT
          echo "kbytes=$KBYTES" >> $GITHUB_OUTPUT

      - name: Create PackageInfo (minimal)
        run: |
          cat > PackageInfo <<EOF
          <?xml version="1.0" encoding="utf-8"?>
          <pkg-info format-version="2"
            identifier="${PKG_IDENTIFIER}"
            version="${APP_VERSION}"
            install-location="/"
            auth="root">
            <payload installKBytes="${{ steps.stats.outputs.kbytes }}" numberOfFiles="${{ steps.stats.outputs.files }}"/>
            <scripts/>
          </pkg-info>
          EOF

      - name: Build component package (pkgbuild)
        run: |
          pkgbuild \
            --root payload \
            --install-location / \
            --identifier "${PKG_IDENTIFIER}" \
            --version "${APP_VERSION}" \
            "${APP_NAME}-unsigned.pkg"

      # ====== OPCJONALNIE: Podpis ======
      - name: Import Developer ID Installer certificate
        if: env.SHOULD_SIGN == 'true'
        run: |
          echo "${{ secrets.INSTALLER_CERT_P12 }}" | base64 --decode > installer.p12
          security create-keychain -p temp build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p temp build.keychain
          security import installer.p12 -k build.keychain -P "${{ secrets.INSTALLER_CERT_P12_PASSWORD }}" -T /usr/bin/productsign -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k temp build.keychain
          rm -f installer.p12

      - name: Sign installer (productsign)
        if: env.SHOULD_SIGN == 'true'
        env:
          # PODMIEŃ na pełną nazwę certyfikatu jak w Keychain, np.:
          # Developer ID Installer: Imię Nazwisko (TEAMID)
          INSTALLER_CN: "Developer ID Installer: YOUR NAME (TEAMID)"
        run: |
          productsign \
            --sign "${INSTALLER_CN}" \
            "${APP_NAME}-unsigned.pkg" \
            "${APP_NAME}-signed.pkg"

      # ====== OPCJONALNIE: Notaryzacja ======
      - name: Notarize with notarytool (API key)
        if: env.CAN_NOTARIZE_API == 'true'
        env:
          NOTARY_API_KEY_ID: ${{ secrets.NOTARY_API_KEY_ID }}
          NOTARY_API_ISSUER: ${{ secrets.NOTARY_API_ISSUER }}
          NOTARY_API_KEY: ${{ secrets.NOTARY_API_KEY }}
        run: |
          echo "$NOTARY_API_KEY" > api_key.p8
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --key api_key.p8 \
            --key-id "$NOTARY_API_KEY_ID" \
            --issuer "$NOTARY_API_ISSUER" \
            --wait
          rm -f api_key.p8

      - name: Notarize with notarytool (Apple ID)
        if: env.CAN_NOTARIZE_APPLEID == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
          APP_SPECIFIC_PW: ${{ secrets.APP_SPECIFIC_PW }}
        run: |
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APP_SPECIFIC_PW" \
            --wait

      - name: Staple ticket (optional)
        run: |
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          xcrun stapler staple "$PKG" || true

      - name: Prepare artifact
        run: |
          mkdir -p dist
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          mv "$PKG" "dist/${APP_NAME}-${APP_VERSION}.pkg"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg
          path: dist/*.pkg
