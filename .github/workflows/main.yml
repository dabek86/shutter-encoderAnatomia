name: Build macOS PKG

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-pkg:
    runs-on: macos-latest

    env:
      APP_NAME: "Shutter Encoder Anatomia"              # Twoja nazwa app
      APP_VERSION: "19.4.0"                             # ← podmień
      PKG_IDENTIFIER: "pl.dabek86.shutterencoder"       # ← podmień
      SHOULD_SIGN: ${{ secrets.INSTALLER_CERT_P12 && secrets.INSTALLER_CERT_P12_PASSWORD && 'true' || 'false' }}
      CAN_NOTARIZE_API: ${{ secrets.NOTARY_API_KEY_ID && secrets.NOTARY_API_ISSUER && secrets.NOTARY_API_KEY && 'true' || 'false' }}
      CAN_NOTARIZE_APPLEID: ${{ secrets.APPLE_ID && secrets.TEAM_ID && secrets.APP_SPECIFIC_PW && 'true' || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Temurin JDK (for jpackage)
        run: |
          brew update
          brew install --cask temurin

      - name: Build .app with jpackage (NO self-inclusion)
        run: |
          set -euo pipefail
          # 1) Czyścimy output
          rm -rf out && mkdir -p out

          # 2) Tworzymy staging tylko z JAR-em głównym
          rm -rf stage && mkdir -p stage
          cp "Shutter Encoder.jar" stage/

          # 3) Zasoby do osobnego katalogu res/ (BEZ out/, .git itd.)
          rm -rf res && mkdir -p res
          # kopiujemy tylko to, co potrzebne
          [ -d Library ] && rsync -a --delete --exclude '.DS_Store' Library/ res/Library/ || true
          [ -d fonts ]   && rsync -a --delete --exclude '.DS_Store' fonts/   res/fonts/   || true
          # UWAGA: Nie kopiujemy out/ do res/! (domyślnie go tu nie ma)

          # 4) Generujemy app-image - input to WYŁĄCZNIE stage/
          jpackage \
            --type app-image \
            --name "${APP_NAME}" \
            --app-version "${APP_VERSION}" \
            --input stage \
            --main-jar "Shutter Encoder.jar" \
            --resource-dir res \
            --dest out

          # out/${APP_NAME}.app gotowe

      - name: Prepare payload
        run: |
          mkdir -p "payload/Applications"
          cp -R "out/${APP_NAME}.app" "payload/Applications/${APP_NAME}.app"

      - name: Compute payload stats
        id: stats
        run: |
          FILES=$(find payload -type f | wc -l | tr -d ' ')
          KBYTES=$(du -sk payload | awk '{print $1}')
          echo "files=$FILES" >> $GITHUB_OUTPUT
          echo "kbytes=$KBYTES" >> $GITHUB_OUTPUT

      - name: Create PackageInfo (minimal)
        run: |
          cat > PackageInfo <<EOF
          <?xml version="1.0" encoding="utf-8"?>
          <pkg-info format-version="2"
            identifier="${PKG_IDENTIFIER}"
            version="${APP_VERSION}"
            install-location="/"
            auth="root">
            <payload installKBytes="${{ steps.stats.outputs.kbytes }}" numberOfFiles="${{ steps.stats.outputs.files }}"/>
            <scripts/>
          </pkg-info>
          EOF

      - name: Build component package (pkgbuild)
        run: |
          pkgbuild \
            --root payload \
            --install-location / \
            --identifier "${PKG_IDENTIFIER}" \
            --version "${APP_VERSION}" \
            "${APP_NAME}-unsigned.pkg"

      - name: Import Developer ID Installer certificate (optional)
        if: env.SHOULD_SIGN == 'true'
        run: |
          echo "${{ secrets.INSTALLER_CERT_P12 }}" | base64 --decode > installer.p12
          security create-keychain -p temp build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p temp build.keychain
          security import installer.p12 -k build.keychain -P "${{ secrets.INSTALLER_CERT_P12_PASSWORD }}" -T /usr/bin/productsign -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k temp build.keychain
          rm -f installer.p12

      - name: Sign installer (optional)
        if: env.SHOULD_SIGN == 'true'
        env:
          INSTALLER_CN: "Developer ID Installer: YOUR NAME (TEAMID)"   # ← PODMIEŃ
        run: |
          productsign \
            --sign "${INSTALLER_CN}" \
            "${APP_NAME}-unsigned.pkg" \
            "${APP_NAME}-signed.pkg"

      - name: Notarize with notarytool (API key) (optional)
        if: env.CAN_NOTARIZE_API == 'true'
        env:
          NOTARY_API_KEY_ID: ${{ secrets.NOTARY_API_KEY_ID }}
          NOTARY_API_ISSUER: ${{ secrets.NOTARY_API_ISSUER }}
          NOTARY_API_KEY: ${{ secrets.NOTARY_API_KEY }}
        run: |
          echo "$NOTARY_API_KEY" > api_key.p8
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --key api_key.p8 \
            --key-id "$NOTARY_API_KEY_ID" \
            --issuer "$NOTARY_API_ISSUER" \
            --wait
          rm -f api_key.p8

      - name: Notarize with notarytool (Apple ID) (optional)
        if: env.CAN_NOTARIZE_APPLEID == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
          APP_SPECIFIC_PW: ${{ secrets.APP_SPECIFIC_PW }}
        run: |
          xcrun notarytool submit "$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APP_SPECIFIC_PW" \
            --wait

      - name: Staple (optional)
        run: |
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          xcrun stapler staple "$PKG" || true

      - name: Prepare artifact
        run: |
          mkdir -p dist
          PKG="$([ -f "${APP_NAME}-signed.pkg" ] && echo "${APP_NAME}-signed.pkg" || echo "${APP_NAME}-unsigned.pkg")"
          mv "$PKG" "dist/${APP_NAME}-${APP_VERSION}.pkg"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg
          path: dist/*.pkg
